# TIL Day8
### 2024.04.04 목요일

---

## [오늘의 기록]

#### [오늘 한 일]
1. Python
- Baekjoon Step5 문자열 [단계 6] 10809번 알파벳 찾기 해결

#### - 2024.04.04 목요일 현재
- Python: Baekjoon STEP/Step5 - 6단계까지 기록 완료
- Python: Programmers Introductory/Day2까지 기록 완료  
- Python: [Notion Python](https://handsome-umbrella-c52.notion.site/Python-6d76c849802f40adb35ca7366565e1e8?pvs=4)  
: 변수와 자료형까지 정리 완료
- Machine_Learning: [Notion 머신러닝](https://handsome-umbrella-c52.notion.site/a887c58b105a44d287c8f5d045e56f4e?pvs=4)  
: 머신러닝 선형회귀모델까지 정리 완료

---
## [오늘의 새로운 학습]
### Python
#### <Baekjoon - Step5: [단계 6] 10809번 알파벳 찾기>
#### 문제  
알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.

#### 출력
각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.

만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.

#### 예제 입력/출력
- 예제 입력: baekjoon
- 예제 출력: 1 0 -1 -1 2 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1

#### 정답
```python
li = []
S = input()
for i in range(97,123): #소문자 비교 => chr(97) ~ chr(122) / 'a' ~ 'z'
  n = -1
  for s in range(len(S)):
    if S[s] == chr(i):
      n = s
      break
  li.append(n)
print(*li)
```
## 해결한 방법
```python
if S[s] == char(i):
    li.append(s)
else:
    li.append(-1)
```
처음에는 아무생각 없이 이 코드로  풀었는데, 이 코드대로 풀면 같지 않지 않을 때 계속해서 -1이 들어가기 때문에 오류가 생긴다. 이 부분을 다음과 같은 사고 과정으로 해결했다.
1. 출력이 알파벳 26개인 점  
: 제일 큰 틀을 `for i in range(97~123)`로 두고 `li.append(n)`를 출력으로 두어 출력 갯수 유지
- 여기서 힌트를 얻은 게 n을 사용하는 것
2. n을 사용  
: 맨 처음 문제였던 같지 않을 때 계속해서 -1이 들어가는 문제를 n=-1로 초기화 한 후 같을 때면 n에 맨 처음 등장하는 위치인 s를 넣고, 아니면 계속 -1을 유지해서 마지막에 list에 넣는 방식으로 해결했다. 그리고 n이 같은 후에 또 검사를 하면 다시 n에 -1이 들어가기 때문에 break를 통해 같은 것을 찾은 즉시 for문을 빠져나오도록 설계했다.
- 이때 li.append(n) 대신 li[i-97] == n을 사용하면 범위를 벗어났다는 오류가 계속 발생했는데 이 오류가 왜 생겼는지를 아직 밝혀내지 못했다.
3. 이렇게 코드를 짜면 앞에 찾은 알파벳은 검사하지 않기 때문에 처음 등장하는 위치라는 조건은 만족한다  
ex) baekjoon에서 o가 두 번 반복되지만 이미 앞에서 검사했기 때문에 두 번째 o는 아무런 영향을 미치지 못한다